"""
202. 快乐数
编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。

如果 n 是快乐数就返回 True ；不是，则返回 False 。



示例：

输入：19
输出：true
解释：
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
"""
"""
方法一：用 HashSet 检测循环

根据我们的探索，我们猜测会有以下三种可能。
最终会得到 1。
最终会进入循环。
值会越来越大，最后接近无穷大。

对于 3 位数的数字，它不可能大于 243。这意味着它要么被困在 243 以下的循环内，
要么跌到 1。4 位或 4 位以上的数字在每一步都会丢失一位，直到降到 3 位为止。
所以我们知道，最坏的情况下，算法可能会在 243 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 1。
但它不会无限期地进行下去，所以我们排除第三种选择。

即使在代码中你不需要处理第三种情况，你仍然需要理解为什么它永远不会发生，这样你就可以证明为什么你不处理它。

算法：

算法分为两部分，我们需要设计和编写代码。

给一个数字 n，它的下一个数字是什么？
按照一系列的数字来判断我们是否进入了一个循环。
第 1 部分我们按照题目的要求做数位分离，求平方和。

第 2 部分可以使用 HashSet 完成。每次生成链中的下一个数字时，我们都会检查它是否已经在 HashSet 中。

如果它不在 HashSet 中，我们应该添加它。
如果它在 HashSet 中，这意味着我们处于一个循环中，因此应该返回 false。
我们使用 HashSet 而不是向量、列表或数组的原因是因为我们反复检查其中是否存在某数字。检查数字是否在哈希集中需要 O(1) 的时间，
而对于其他数据结构，则需要 O(n) 的时间。选择正确的数据结构是解决这些问题的关键部分。

复杂度分析

确定这个问题的时间复杂度对于一个 “简单” 级别的问题来说是一个挑战。如果您对这些问题还不熟悉，可以尝试只计算 getNext(n) 函数的时间复杂度。

时间复杂度：O(243⋅3+logn+loglogn+logloglogn)... = O(logn)。
查找给定数字的下一个值的成本为 O(logn)，因为我们正在处理数字中的每位数字，而数字中的位数由 logn 给定。
要计算出总的时间复杂度，我们需要仔细考虑循环中有多少个数字，它们有多大。
我们在上面确定，一旦一个数字低于 243，它就不可能回到 243 以上。因此，我们就可以用 243243 以下最长循环的长度来代替 243，
不过，因为常数无论如何都无关紧要，所以我们不会担心它。
对于高于 243 的 n，我们需要考虑循环中每个数高于 243 的成本。通过数学运算，我们可以证明在最坏的情况下，
这些成本将是 O(logn)+O(loglogn)+O(logloglogn)...。幸运的是，O(logn) 是占主导地位的部分，而其他部分相比之下都很小
（总的来说，它们的总和小于logn），所以我们可以忽略它们。
空间复杂度：O(logn)。与时间复杂度密切相关的是衡量我们放入 HashSet 中的数字以及它们有多大的指标。
对于足够大的 nn，大部分空间将由 n 本身占用。我们可以很容易地优化到 O(243⋅3)=O(1)，方法是只保存集合中小于 243 的数字，
因为对于较高的数字，无论如何都不可能返回到它们。

执行用时：60 ms, 在所有 Python3 提交中击败了8.62%的用户
内存消耗：14.8 MB, 在所有 Python3 提交中击败了28.10%的用户
"""
class Solution:
    def isHappy(self, n):

        def get_next(n):
            total_sum = 0
            while n > 0:
                n, digit = divmod(n, 10)
                total_sum += digit ** 2
            return total_sum

        seen = set()
        while n != 1 and n not in seen:
            seen.add(n)
            n = get_next(n)

        return n == 1


if __name__ == "__main__":
    s = [1,2,2,1]
    A = Solution()
    print(A.isHappy(s))
